	Тут буде пояснюватися сутність коду, його функції та інше. Загальний опис про X3DH.

	- Маємо дві структури: пару ключів і пару для збереження ключів чотирьох типів.

	- Повний функціонал:

		- генерація пари ключів для IK, EK, SPK, OPK (generateKeyPair());
		- генерація пари ключів (generateKeyPairSign());		
		- генерація ідентифікаційних ключів (generateIK());
		- генерація ефемерних ключів (generateEK());
		- генерація ключів, підписаних ідентифікаційним ключем (generateSPK(..., ...));
		- генерація одноразових ключів (generateOPK());
		- збереження ключів (saveKeys(..., ...));
		- завантаження ключів (loadKey(...));
		- завантаження приватного ключа (loadPrivateKey(...));
		- завантаження публічного ключа (loadPublicKey(...));
		- конвертація ключа в байти (convertPKeyToByteArray(...));
		- реалізація кожного етапу DH (computeSharedSecret(..., ...));
		- реалізація кінцевого X3DH, тобто визначення спільного секрету (generateSharedSecret(..., ..., ..., ..., ...)).

	Опис кожної функції:

	1. Функція generateKeyPair(): генерація ключів базується на EC (X25519). Використано структуру відкритого ключа EVP_PKEY_CTX*, 
	яка не дозволяє використовувати один і той самий контекст одночасно у двох потоках. Rvalue реалізовано за допомогою EVP_PKEY_CTX_new_id, 
	що дозволяє повернути згенеровану пару ключів. У випадку помилки повертається NULL. Для ініціалізації ключа використовується 
	EVP_PKEY_keygen_init(). Якщо довжина дорівнює 0, виникає помилка. Після цього ключ генерується за допомогою EVP_PKEY_keygen, і 
	результат зберігається в змінну pkey. Використано BIO для забезпечення безпеки ключів через часте використання цієї функції. 
	Абстракція вводу-виводу приймає різні потоки даних, прозоро обробляє SSL-з'єднання, незахищені мережеві підключення та файловий 
	ввід-вивід. BIO пам'яті розширюється для збереження даних, записаних у структуру BUF_MEM. Якщо виникає помилка, ресурси звільняються. 
	Ключі зберігаються у форматі PEM, використовується вказівник на структуру BUF_MEM. Повертається пара ключів.

	2. Функція generateKeyPairSign(): працює аналогічно до generateKeyPair, але використовує X25519.

	3. Функція generateIK(): використовує функцію generateKeyPair().

	4. Функція generateEK(): використовує функцію generateKeyPair().

	5. Функція generateSPK(const QByteArray& IK_privateKey).

	6. Функція saveKeys(const QByteArray &keyData, const QString &fileName): зберігає файли.

	7. Функція loadKey(const QString& filename): завантажує файли.

	8. Функція loadPrivateKey(const QByteArray& keyData): перевіряє наявність даних і формат ключа, створює потік BIO і зчитує дані.

	9. Функція loadPublicKey(const QByteArray& keyData): ідентична функції loadPrivateKey(const QByteArray& keyData).

	10. Функція convertPKeyToByteArray(EVP_PKEY* pkey): перевіряє наявність ключа, створює потік, записує в буфер і звільняє ресурси.

	11. Функція signData(const QByteArray& data, const QByteArray& privateKey): створює потік для приватного ключа, завантажує ключ 
	через PEM_read_bio_PrivateKey, ініціалізує підпис за допомогою EVP_DigestSignInit і виконує підпис даних EVP_DigestSign.

	12. Функція computeSharedSecret(const KeyPair& localKey, const QByteArray& remotePublicKey): Призначена для генерації спільного
	секрету на основі кількох етапів обчислення проміжних секретів із використанням алгоритму Діффі-Геллмана та подальшого застосування 
	HKDF для отримання фінального ключа. На першому етапі виконується перевірка вхідних даних, щоб переконатися, що всі ключі 
	(IK_A, EK_A, IK_B, SPK_B, OPK_B) не є порожніми. Якщо будь-який із них відсутній, викидається виключення std::invalid_argument.
	Далі обчислюються проміжні секрети (DH1, DH2, DH3, DH4) за допомогою функції computeSharedSecret(). Ці секрети визначаються таким чином:
	DH1 – спільний секрет між IK_A та SPK_B,
	DH2 – спільний секрет між EK_A та IK_B,
	DH3 – спільний секрет між EK_A та SPK_B,
	DH4 – спільний секрет між EK_A та OPK_B.
	Усі проміжні значення виводяться в лог у вигляді шістнадцяткового представлення для налагодження. Після цього всі проміжні секрети 
	об’єднуються в один масив байтів concatenatedSecret, який перевіряється на порожнечу. Якщо масив порожній, викидається виключення 
	std::runtime_error. Потім використовується HKDF із алгоритмом хешування SHA-256 для генерації фінального ключа. Контекст HKDF 
	створюється за допомогою EVP_KDF і EVP_KDF_CTX. Як сіль використовується порожнє значення, Як ключ — об’єднаний секрет concatenatedSecret.
	Параметри для HKDF задаються через масив OSSL_PARAM, що включає: Алгоритм хешування (SHA256), Сіль (salt), Ключ (key). Фінальний ключ 
	витягується методом EVP_KDF_derive і зберігається в масиві outKey довжиною 32 байти (256 біт). Після завершення роботи звільняються 
	контексти EVP_KDF_CTX та EVP_KDF, щоб уникнути витоків пам’яті. Фінальний ключ повертається у вигляді об’єкта QByteArray.
	Контекст EVP_KDF і структура OSSL_PARAM забезпечують гнучкість налаштування HKDF, включаючи вибір алгоритму хешування.

	13. Функція signData(const QByteArray& data, const QByteArray& privateKey): Використовується абстракція введення-виведення, де rvalue 
	застосовує функцію BIO_new_mem_buf. У неї передається довжина байтових даних у буфері. Якщо довжина дорівнює -1, то вона вважається 
	нульовою, а її значення визначається через strlen. BIO налаштований на режим читання, тому до нього неможливо записувати дані. Це корисно, 
	коли певні дані потрібно зробити доступними зі статичної області пам’яті у вигляді BIO. Ця область має залишатися незмінною.
	Тип EVP_MD — це структура для реалізації методу дайджесту. За допомогою цього методу EVP_MD_CTX_new виділяється контекст дайджесту. 
	Далі виконується підпис даних за допомогою EVP_DigestSignInit, де використовуються: Дайджест, Закритий ключ. Дайджест може мати 
	значення NULL, якщо алгоритм підписання не підтверджений. У такому разі він виводить параметр mdname, а props приймає значення NULL.
	Там, де використовується ENGINE, відбувається реалізація алгоритму підпису та дайджесту. Функція повертає підписані дані.