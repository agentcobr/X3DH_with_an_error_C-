	Тут будет объяснятся суть кода, его функции и прочее. Общее объяснение про X3DH
	
	- Имеем две структуры, пару ключей и пару сохранения ключей 4-ох типов.
	
	- Полный функционал:
		- генерация пары ключей для IK, EK, SPK, OPK (generateKeyPair())
		- генерация парі ключей (generateKeyPairSign())
		- генерация идентификаонных ключей (generateIK())
		- генерация эфеморфных ключей (generateEK())
		- генерация ключей подписанных идентификационным ключем (generateSPK(..., ...)
		- генерация одноразовых ключей (generateOPK())
		- сохранения ключей (saveKeys(..., ...)
		- загрузка ключей (loadKey(...)
		- загрузка приватного ключа (loadPrivateKey(...))
		- загрузка публичного ключа (loadPublicKey(...))
		- конвертация ключа в байты (convertPKeyToByteArray(...)
		- реализация каждого этапа DH (computeSharedSecret(..., ...)
		- реализация конечного X3DH, то определения общего секрета (generateSharedSecret(..., ..., ..., ..., ...))
	
	- Описание каждой функции 
	1. Функиця generateKeyPair(): генерация ключей основана на EC (X25519). Была использована структура открытого ключа
 	   EVP_PKEY_CTX*, ее особенность в том, что невозможно использовать одного и того же контексту одновременно в двух 
	   потоках. Rvalue реализовалось с помощью EVP_PKEY_CTX_new_id, что позволи ему вернуть сгенерированную пару, если 
           бы была ошибка, то вернуло NULL. В этом случае EVP_PKEY_keygen_init() выполняется инициализация ключа за ранее 
	   установлено (зарезервировано), если будет длина 0, то будет ошибка. Теперь выполняем создания ключа с помощью 
	   EVP_PKEY_keygen, у нас есть инициализированная переменная pkey в которую будет сохранено ключи.
	   Решено использовать BIO для безопасности использования ключей, так как будет огромное количество использование 
	   этой функции. Абстрация вывода-ввода приммает множество вводов-выводов от программы, прозрачно обрабатывает 
	   подключения SSL, незащищенные сетевые подключения и файловый ввод-вывод. В функции использовали BIO памяти, он 
	   используется памятью для собстевенного ввода-вывода, которая расширяется для размещения сохранения данных. 
	   Данные, которые записаны в BIO памяти, сохраняются в структуре BUF_MEM, которая соответственно расширяется 
	   сохранения данных. Если проверка при проверке будет ошибка, то мы освобождаем цепь. Потом просходит запись ключей
	   в формате PEM. Создаем указатель, который реализирует базовую структуру BUF_MEM, а это макрос. Возвращаем пару
	   ключей. 
	
	2. Функция (generateKeyPairSign(), работает по такому же принципу, что и generateKeyPair, но использует X25519
	
	3. Функция generateIK(), она использует фунцию generateKeyPair()

	4. Функция generateEK(), она использует фунцию generateKeyPair()

	5. Функция generateSPK(const QByteArray& IK_privateKey) 

	6. Функция saveKeys(const QByteArray &keyData, const QString &fileName) сохраняет файлы 

	7. Функция loadKey(const QString& filename) загружает файлы 
	
	8. Функция loadPrivateKey(const QByteArray& keyData): выполняется проверка, что данные есть и также формат ключа, 
	   Далеее мы создаем поток BIO для него же и считываем 
	
	9. Функция loadPublicKey(const QByteArray& keyData): одинакова с функцией loadPrivateKey(const QByteArray& keyData)

	10. Функция convertPKeyToByteArray(EVP_PKEY* pkey): проверяем есть ли ключ, далее создаем поток и записываем в 
	   буфер, и в скоре, освобождаем 

	11. Функция signData(const QByteArray& data, const QByteArray& privateKey): создаем поток приватного ключа, потом 
	  загружаем ключ с помощью PEM_read_bio_PrivateKey, создаем контекст для подписи (ctx) и инициализируем подпись 
   	  (EVP_DigestSignInit) и подписываем данные (EVP_DigestSign)

	12. Функция computeSharedSecret(const KeyPair& localKey, const QByteArray& remotePublicKey): предназначена для 
	  генерации общего секрета на основе нескольких этапов расчета промежуточных секретов с использованием алгоритма 
	  Диффи-Хеллмана и последующего применения HKDF для получения итогового ключа. На первом этапе осуществляется проверка 
	  входных данных, чтобы убедиться, что все ключи (IK_A, EK_A, IK_B, SPK_B, OPK_B) не являются пустыми. Если один из 
	  них отсутствует, выбрасывается исключение std::invalid_argument. Далее вычисляются промежуточные секреты 
	  (DH1, DH2, DH3, DH4) с использованием функции computeSharedSecret(). Эти секреты определяются следующим образом: 
	  DH1 – общий секрет между IK_A и SPK_B, DH2 – общий секрет между EK_A и IK_B, DH3 – общий секрет между EK_A и SPK_B, 
 	  DH4 – общий секрет между EK_A и OPK_B. Все промежуточные значения выводятся в лог в виде шестнадцатеричного представления 
	  для отладки. После этого все промежуточные секреты объединяются в один массив байтов concatenatedSecret, который 
	  проверяется на пустоту. Если он пуст, выбрасывается исключение std::runtime_error. Затем используется HKDF с 
	  алгоритмом хэширования SHA-256 для генерации финального ключа. Контекст HKDF создается с помощью EVP_KDF и EVP_KDF_CTX. 
	  В качестве соли используется пустое значение, а в качестве ключа — объединенный секрет concatenatedSecret. Параметры 
	  для HKDF задаются через массив OSSL_PARAM, включающий алгоритм хэширования (SHA256), соль (salt) и ключ (key). 
	  Финальный ключ извлекается методом EVP_KDF_derive и сохраняется в массиве outKey длиной 32 байта (256 бит). После 
	  завершения работы освобождаются контексты EVP_KDF_CTX и EVP_KDF для предотвращения утечек памяти. Итоговый ключ 
	  возвращается в виде объекта QByteArray. Контекст EVP_KDF и структура OSSL_PARAM обеспечивают гибкость настройки HKDF, 
	  включая выбор алгоритма хэширования.

	13. Функция signData(const QByteArray& data, const QByteArray& privateKey): используем абстракцию ввода-вывода, где 
	   rvalue использует функцию BIO_new_mem_buf, в нее входит длина байтов данных в буффере, если длина равно -1, тогда
	   считается нулевым, а его длина определяется strlen. BIO настроено на режим чтения, то в него невозможно записать. 
 	   Это полезно, когда определенные данные нужно сделать доступными из статической области памяти в форме BIO, эта
	   область должна оставаться неизменной. Тип EVP_MD - это структура для реализации методу дайджесту. С помошью этого 
	   метода EVP_MD_CTX_new мы выделяем контекст дайджест, далее мы подписываем с помощью EVP_DigestSignInit, где был 
	   использован дайджест и закрытый ключ. Дайджест может иметь значение NULL, если не подтверждено алгоритм подписания; 
	   он выводит параметр mdname, а props имеет значения NULL. Там, где имеется ENGINE, то йде реализация алгоритму 
	   подписи и дайджесту. Возвращает подпись 
	